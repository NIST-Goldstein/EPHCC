# HIL
Microgrid Controller Display

Real-time displays to view the status of the HIL system

# Installation Instructions:

To run the display code, you first need to install and configure a webserver with php support.

To duplicate our set up, install Ubuntu 16.06 followed by apache2 (apt-get install apache2) followed by php (sudo apt-get install php libapache2-mod-php php-mcrypt). In php.ini set short_open_tag to be On. 

Once configured, moving the Display folder from the repository into the html folder on your system(generally /var/www/html) should make it accessible from the browser. To test, open a browser on the system (Firefox or Chrome) and navigate to http://localhost/HILHCI/ You should see a list of files in the HIL folder.

IMPORTANT LICENSING NOTE: The graphs page uses the library CanavasJS from http://canvasjs.com. Included is their demo version of the library. Please familiarize yourself with their licesnsing.

In the perl folder, there's script called "hilReceiver.pl" this script recieves the packets from the HIL system and places them in the right location for the webapp to access.

Edit the file called hilreceiver located in the perl folder. Update the variable PROG_PATH to properly refelct the location of the perl script. Copy the script to /etc/init.d/ folder to make it a service.

Run from command line "sudo update-rc.d hilreceiver defaults" to make it start on boot.

Currently, we do not use a database to store the data. Data stored as flat files in the system.

# Packet

The HIL Displays rely on incoming packets from the HIL system. The perl script mentioned above parses the packets. 

The current packet format requires for each field to be a signed int32 with the first byte being 44975 and the last byte being 21845

Following the start byte is the header which contains all of the information needed to decode the rest of the packet. The data in the packet will be in the same order as the header. Please look at the decodPacket sub in the common_functions.pl script to see how the pakcet is decoded.

The header contains the following information:

profileId - which profile is the data for. The current options are 1 (Sherrif), 2 (Banshee), or 3 (Canary). 
simtime - current time in the simulation 
numberOfWaveforms - number of wave forms data is being sent for (in Sherrif were were sending 3 in Banshee we were sending 0)
numberOfPointsInWaveform - number of waveform points sent in this packet
scaleOfWaveform - what divide each waveform value by (we do this since int32 doesn't allow for decimals)

number of relays - number of breakers (real power, reactive power, voltage, frequency will also have the same amount) in the simulation we wish to display. This number will match the number in the packet allowing us to itterate over the packet based on this number
	scale of real power values - what to divide real power by
	scale of reactive power values - 
	scale of voltage values - 
	scale of frequency values - 

number of batteries -
	battery state of charge scale -
	battery VRMSLL scale - 
	battery Frequency scale -
	battery kW scale -
	battery kVAR scale - 

number of dieselGenerators - 
	dieselGenerator voltage scale - 
	dieselGenerator fuelConsumption scale -
	
number of ngchpGenerators -
	ngchpGenerator voltage scale - 
	ngchpGenerator tempActual scale - 
	ngchpGenerator heatRecovered scale -
	ngchpGenerator fuelUsage scale -
	ngchpGenerator ChpC02 scale -
	ngchpGenerator boilerHeat scale -
	ngchpGenerator CHPHeatContribution scale -
	ngchpGenerator boilerNM scale -
	ngchpGenerator boilerLbm scale -

number of motors

number of solar devices
	solar VRMSLL scale -
	solar kW scale -
	solar kVAR scale -

number of power factors
	power factors scale
	
numberOfMiscDataScales - This is the number of other data items we are sending

For each miscDataScale there are two values (call it a sub header):
	number of items at this scale
	scale for these items
	
	
Once the packet is decoded data is written to the data directory. The top level of the data directory contains folders that match the ID of the packet received. So if the system is receiving packets for Sherrif, there will be a folder named "1". If it had received packets for other profiles in the past, there will be other folders too ("2", "3", etc). 

There is also a file named "latest.id". This file contains a pointer to the latest profile id we've received and the name of the folder inside that profile id we are currently writing to. This tells the visualization code where to read the data from. For example "2,03-28-2017-15-19-21" would tell it we are using profile 2 and the folder for the latest data is 03-28-2017-15-19-21.

The folder names are automatically generated by the perl receiver based on the date/time of the first packet received for that id. If there's a break of over 10 seconds in the data, the script assumes the simulation run has ended and any packet received after that will be written to a new folder. The script will also tar/gz the old data for ease of sharing.

Each run folder (such as 03-28-2017-15-19-21) contains data files for each of the items described in the header above. Each files is comma seperated with the time stamp being the first value and data items being the rest of the values. The number of data items matches the nuber field in the header for that item.

Currently the HIL sends 5 packets a second.

For debugging there's now new tool named "hilSenderFromData.pl" it's still in the beta but if you edit it and update these values to match the run you want to replay and run it, it will simulate as if packets are being sent from the HIL:
my $folder = '02-16-2017-22-01-49';
my $profileid = 2;

# Displays

For each profile there's a settings file. There are pretty large and pretty self explanitory. The settings file define where each item on the screen is displayed and what it's linked to. It's in JSON format. The settings files are located in the assets/js/profiles/ folder. 

Each profile needs an underlying graphic to represent the system map. If you want, you can just place a blank background and map out where each item is in the system in the settings file. The only thing that will be missing is lines connecting the components.

There are two displays currently: graphs and systemprofile. To load either one navigate your browser to http://localhost/HILHCI/ and open either graphs.php or sysprofile.php. Note that you won't see anything if there's no data in the data dir OR the latest.id file points to an invalid data folder.

There are many type of graphs that are supported. The documentation for this will be written in the future.

For the system profile view, each of the components described in the header (and some not described in the header) has an entry in the .json config file. If there's a section in the json config file for a component, there also exists a corresponding javascript library for it. You can view all of the componenets in assets\js\components. To add a new componenet you can copy the general template of any other componenet. To enable it, add it to the settings json file described above just like the other componenets. The system profile code loops through the settings file to enable the components. If it detects there's no corresponding library it will skip that component. There's also a second loop to update the data for each componenet. 

The front HTML/js code queries the backend by making ajax calls to the ajax_controller.php (we can call it an API) to get the data. That controller figures out the query and calls the right function defined in functions.php to get the data. Most of the time for systemprofile it just tails tha latest row but for the graph it usually gets a bunch of rows based on the start/stop line number passed in by the front end.